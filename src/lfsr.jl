
export LFSR, lfsrtaps

struct LFSR{N, F}
    taps    :: NTuple{N, Int}
    #state   :: BitVector
    state   :: Vector{Bool}
    mapping :: NTuple{2, F}
end

"""
    LFSR(taps::NTuple{N, Int} ; seed = trues(N), mapping = (true, false))

Create an infinite, stateful iterator that returns values generated by a linear shift
register with the specified taps. Taps must be specified in descending order, assuming
Fibonacci notation.

The shift register is initialized to all ones by default, but a different starting state
may be specified using the `seed` keyword argument.

By default, the iterator produces values of type `Bool`. Using the `mapping` keyword,
a tuple `(outputwhentrue, outputwhenfalse)` may be used to specify different iterator
output values.

# Examples

```jl
# Create a maximum-length LFSR with period 16
julia> l = LFSR((4,3))
LFSR{2, Bool}((4, 3), Bool[1, 1, 1, 1], (true, false))

# Get the first five values from the sequence
julia> first(l, 5)
5-element Vector{Bool}:
 0
 0
 0
 1
 0

# Change the output to `1.0` and `-1.0` for `true` and `false`, respectively
julia> l = LFSR((4,3), mapping = (1.0, -1.0))
LFSR{2, Float64}((4, 3), Bool[1, 1, 1, 1], (1.0, -1.0))

julia> first(l, 5)
5-element Vector{Float64}:
 -1.0
 -1.0
 -1.0
  1.0
 -1.0

# use `lfsrtaps` to define a sequence of length `2^16-1`
julia> l = LFSR(lfsrtaps[16])
LFSR{4, Bool}((16, 15, 13, 4), Bool[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], (true, false))
```

See also `lfsrtaps`.
"""
function LFSR(taps::NTuple{N, Int} ; seed = ones(Bool, taps[1]), mapping = (true,false)) where N
    # validate
    N > 1 || error("At least two taps must be specified: ", taps)
    for idx in 1:N
        idx == N && break
        taps[idx] < taps[idx+1] && error("Taps must be specified in descending order: ", taps)
    end
    length(seed) != taps[1] && error("Wrong seed length; expected $(taps[1]), got $(length(seed))")
    # initialize
    state = seed
    LFSR(taps, state, mapping)
end

Base.IteratorSize(::Type{LFSR{N, F}}) where {N, F} = Base.IsInfinite()
Base.IteratorEltype(::Type{LFSR{N, F}}) where {N, F} = Base.HasEltype()
Base.eltype(::Type{LFSR{N, F}}) where {N, F} = F
Base.isdone(x::LFSR{N, F}) where {N, F} = false

function Base.iterate(x::LFSR{N, F})::Tuple{F, Nothing} where {N, F}
    # Returns first value of LFSR sequence
    out = false
    for i in 1:N
        out = out âŠ» x.state[x.taps[i]]
    end
    #@inbounds x.state[2:end] .= x.state[1:end-1]  #  <-- allocates
    #@views @inbounds x.state[2:end] .= x.state[1:end-1]  #  <-- allocates and is slow
    for i in length(x.state):-1:2  # does not allocate
        @inbounds x.state[i] = x.state[i-1]
    end
    x.state[1] = out
    return (out ? x.mapping[1] : x.mapping[2], nothing)
end

Base.iterate(x::LFSR, state) = Base.iterate(x)

"""
    lfsrtaps

A dictionary containing taps for maximum-length linear shift register sequences,
for degrees 2 to 24.

The taps were adapted from the list at
https://en.wikipedia.org/wiki/Linear-feedback_shift_register#Fibonacci_LFSRs
"""
lfsrtaps = Dict(2  => (2, 1),
                3  => (3, 2),
                4  => (4, 3),
                5  => (5, 3),
                6  => (6, 5),
                7  => (7, 6),
                8  => (8, 6, 5, 4),
                9  => (9, 5),
                10 => (10, 7),
                11 => (11, 9),
                12 => (12, 11, 10, 4),
                13 => (13, 12, 11, 8),
                14 => (14, 13, 12, 2),
                15 => (15, 14),
                16 => (16, 15, 13, 4),
                17 => (17, 14),
                18 => (18, 11),
                19 => (19, 18, 17, 14),
                20 => (20, 17),
                21 => (21, 19),
                22 => (22, 21),
                23 => (23, 18),
                24 => (24, 23, 22, 17)
               )
